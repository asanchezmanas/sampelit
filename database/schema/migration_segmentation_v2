-- ============================================================================
-- MIGRATION: Segmentation V2 - Correct Architecture
-- ============================================================================
-- PROBLEMA ACTUAL: Las variantes están duplicadas por segmento
-- SOLUCIÓN: Variantes únicas + estado Thompson por (variant_id, segment_key)
--
-- Esta migración es INCREMENTAL y BACKWARD COMPATIBLE
-- ============================================================================

-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 1: Nueva tabla para estado Thompson Sampling por segmento          │
-- └──────────────────────────────────────────────────────────────────────────┘

CREATE TABLE IF NOT EXISTS variant_segment_state (
    -- Clave compuesta: variante + segmento
    variant_id UUID NOT NULL REFERENCES element_variants(id) ON DELETE CASCADE,
    segment_key VARCHAR(100) NOT NULL,
    experiment_id UUID NOT NULL REFERENCES experiments(id) ON DELETE CASCADE,
    
    -- Thompson Sampling state (Beta distribution)
    alpha DECIMAL(12, 4) DEFAULT 1.0 NOT NULL,      -- Prior + successes
    beta DECIMAL(12, 4) DEFAULT 1.0 NOT NULL,       -- Prior + failures
    
    -- Counters para performance tracking
    total_allocations INTEGER DEFAULT 0,
    total_conversions INTEGER DEFAULT 0,
    conversion_rate DECIMAL(5, 4) DEFAULT 0.0,
    
    -- Metadata
    first_seen_at TIMESTAMP DEFAULT NOW(),
    last_allocation_at TIMESTAMP,
    last_conversion_at TIMESTAMP,
    
    -- Confidence metrics (calculados)
    confidence_lower DECIMAL(5, 4),  -- Credible interval lower bound
    confidence_upper DECIMAL(5, 4),  -- Credible interval upper bound
    
    -- Version tracking para migraciones
    state_version INTEGER DEFAULT 1,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    -- Primary key
    PRIMARY KEY (variant_id, segment_key),
    
    -- Indexes para queries comunes
    INDEX idx_variant_segment_experiment (experiment_id, segment_key),
    INDEX idx_variant_segment_performance (experiment_id, segment_key, conversion_rate DESC),
    INDEX idx_variant_segment_updated (updated_at DESC)
);

COMMENT ON TABLE variant_segment_state IS 
'Thompson Sampling state por variante y segmento. Permite que la misma variante tenga diferente performance en diferentes segmentos.';

COMMENT ON COLUMN variant_segment_state.alpha IS 
'Parámetro α de distribución Beta = 1.0 (prior) + total_conversions';

COMMENT ON COLUMN variant_segment_state.beta IS 
'Parámetro β de distribución Beta = 1.0 (prior) + (total_allocations - total_conversions)';


-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 2: Función para auto-crear estado cuando aparece nuevo segmento    │
-- └──────────────────────────────────────────────────────────────────────────┘

CREATE OR REPLACE FUNCTION ensure_variant_segment_state(
    p_variant_id UUID,
    p_segment_key VARCHAR(100),
    p_experiment_id UUID
) RETURNS void AS $$
BEGIN
    INSERT INTO variant_segment_state (
        variant_id, 
        segment_key, 
        experiment_id,
        alpha,
        beta
    )
    VALUES (
        p_variant_id,
        p_segment_key,
        p_experiment_id,
        1.0,  -- Uniform prior
        1.0
    )
    ON CONFLICT (variant_id, segment_key) DO NOTHING;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION ensure_variant_segment_state IS 
'Crea entrada de estado para (variant, segment) si no existe. Usado en allocation time.';


-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 3: Función para incrementar allocations                            │
-- └──────────────────────────────────────────────────────────────────────────┘

CREATE OR REPLACE FUNCTION increment_variant_segment_allocation(
    p_variant_id UUID,
    p_segment_key VARCHAR(100)
) RETURNS void AS $$
BEGIN
    UPDATE variant_segment_state
    SET 
        total_allocations = total_allocations + 1,
        last_allocation_at = NOW(),
        updated_at = NOW()
    WHERE variant_id = p_variant_id 
      AND segment_key = p_segment_key;
      
    -- Si no existe, la creamos (no debería pasar si usamos ensure_variant_segment_state)
    IF NOT FOUND THEN
        RAISE NOTICE 'Variant segment state not found for % / %. Creating...', p_variant_id, p_segment_key;
    END IF;
END;
$$ LANGUAGE plpgsql;


-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 4: Función para incrementar conversions + actualizar Thompson      │
-- └──────────────────────────────────────────────────────────────────────────┘

CREATE OR REPLACE FUNCTION increment_variant_segment_conversion(
    p_variant_id UUID,
    p_segment_key VARCHAR(100)
) RETURNS void AS $$
DECLARE
    v_allocations INTEGER;
    v_conversions INTEGER;
BEGIN
    -- Incrementar conversiones
    UPDATE variant_segment_state
    SET 
        total_conversions = total_conversions + 1,
        last_conversion_at = NOW(),
        updated_at = NOW()
    WHERE variant_id = p_variant_id 
      AND segment_key = p_segment_key
    RETURNING total_allocations, total_conversions 
    INTO v_allocations, v_conversions;
    
    -- Actualizar parámetros Thompson Sampling
    -- Alpha = prior (1.0) + conversiones
    -- Beta = prior (1.0) + fallos
    UPDATE variant_segment_state
    SET 
        alpha = 1.0 + v_conversions,
        beta = 1.0 + (v_allocations - v_conversions),
        conversion_rate = CASE 
            WHEN v_allocations > 0 THEN v_conversions::DECIMAL / v_allocations
            ELSE 0.0
        END
    WHERE variant_id = p_variant_id 
      AND segment_key = p_segment_key;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION increment_variant_segment_conversion IS 
'Incrementa conversiones y actualiza parámetros Thompson Sampling (alpha, beta) automáticamente.';


-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 5: Vista materializada para analytics rápidos                      │
-- └──────────────────────────────────────────────────────────────────────────┘

CREATE MATERIALIZED VIEW IF NOT EXISTS segment_performance_summary AS
SELECT 
    vss.experiment_id,
    vss.segment_key,
    s.metadata->>'description' as segment_description,
    
    -- Aggregate metrics
    COUNT(DISTINCT vss.variant_id) as variant_count,
    SUM(vss.total_allocations) as total_visitors,
    SUM(vss.total_conversions) as total_conversions,
    
    -- Weighted average conversion rate
    CASE 
        WHEN SUM(vss.total_allocations) > 0 
        THEN SUM(vss.total_conversions)::DECIMAL / SUM(vss.total_allocations)
        ELSE 0.0 
    END as avg_conversion_rate,
    
    -- Best performing variant
    (
        SELECT ev.name
        FROM variant_segment_state vss2
        JOIN element_variants ev ON vss2.variant_id = ev.id
        WHERE vss2.experiment_id = vss.experiment_id
          AND vss2.segment_key = vss.segment_key
        ORDER BY vss2.conversion_rate DESC
        LIMIT 1
    ) as best_variant_name,
    
    -- Statistical significance check (simple heuristic)
    CASE 
        WHEN SUM(vss.total_allocations) >= 1000 THEN 'sufficient'
        WHEN SUM(vss.total_allocations) >= 100 THEN 'moderate'
        ELSE 'insufficient'
    END as data_quality,
    
    MAX(vss.updated_at) as last_updated
    
FROM variant_segment_state vss
LEFT JOIN segments s ON s.experiment_id = vss.experiment_id 
    AND s.segment_key = vss.segment_key
GROUP BY vss.experiment_id, vss.segment_key, s.metadata
ORDER BY total_visitors DESC;

CREATE UNIQUE INDEX idx_segment_performance_pk 
    ON segment_performance_summary (experiment_id, segment_key);

COMMENT ON MATERIALIZED VIEW segment_performance_summary IS 
'Vista materializada para dashboards. Refresh con REFRESH MATERIALIZED VIEW CONCURRENTLY.';


-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 6: Trigger para auto-refresh de vista materializada                │
-- └──────────────────────────────────────────────────────────────────────────┘

CREATE OR REPLACE FUNCTION refresh_segment_performance() 
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY segment_performance_summary;
END;
$$ LANGUAGE plpgsql;

-- Nota: En producción, ejecutar esto con un cron job o background task
-- No con un trigger (sería muy pesado)


-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 7: Migración de datos existentes (BACKWARD COMPATIBILITY)          │
-- └──────────────────────────────────────────────────────────────────────────┘

-- Si ya tienes data en element_variants con segment_key, migrarla:
DO $$
BEGIN
    -- Check si la columna segment_key existe en element_variants
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'element_variants' 
        AND column_name = 'segment_key'
    ) THEN
        -- Migrar datos existentes
        INSERT INTO variant_segment_state (
            variant_id,
            segment_key,
            experiment_id,
            alpha,
            beta,
            total_allocations,
            total_conversions,
            conversion_rate,
            created_at
        )
        SELECT 
            ev.id as variant_id,
            COALESCE(ev.segment_key, 'default') as segment_key,
            ev.experiment_id,
            COALESCE(
                (ev.algorithm_state->>'alpha')::DECIMAL, 
                1.0 + COALESCE((ev.algorithm_state->>'success_count')::INTEGER, 0)
            ) as alpha,
            COALESCE(
                (ev.algorithm_state->>'beta')::DECIMAL,
                1.0 + COALESCE((ev.algorithm_state->>'failure_count')::INTEGER, 0)
            ) as beta,
            ev.total_allocations,
            ev.total_conversions,
            CASE 
                WHEN ev.total_allocations > 0 
                THEN ev.total_conversions::DECIMAL / ev.total_allocations
                ELSE 0.0
            END as conversion_rate,
            ev.created_at
        FROM element_variants ev
        ON CONFLICT (variant_id, segment_key) DO UPDATE SET
            alpha = EXCLUDED.alpha,
            beta = EXCLUDED.beta,
            total_allocations = EXCLUDED.total_allocations,
            total_conversions = EXCLUDED.total_conversions,
            conversion_rate = EXCLUDED.conversion_rate;
        
        RAISE NOTICE 'Migrated existing variant segment data to new table';
    END IF;
END $$;


-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 8: Agregar índices para segment tracking en assignments            │
-- └──────────────────────────────────────────────────────────────────────────┘

-- Asegurarnos que assignments puede trackear segment_key
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'assignments' 
        AND column_name = 'segment_key'
    ) THEN
        ALTER TABLE assignments ADD COLUMN segment_key VARCHAR(100);
        
        -- Índice para queries de analytics por segmento
        CREATE INDEX idx_assignments_segment 
            ON assignments(experiment_id, segment_key, converted_at);
        
        RAISE NOTICE 'Added segment_key column to assignments';
    END IF;
END $$;


-- ┌──────────────────────────────────────────────────────────────────────────┐
-- │ STEP 9: Helper query para debugging                                     │
-- └──────────────────────────────────────────────────────────────────────────┘

-- Query útil para ver estado de un experimento segmentado:
/*
SELECT 
    ev.name as variant_name,
    vss.segment_key,
    vss.total_allocations,
    vss.total_conversions,
    vss.conversion_rate,
    vss.alpha,
    vss.beta,
    -- Probabilidad estimada (media de Beta)
    vss.alpha / (vss.alpha + vss.beta) as estimated_cvr
FROM variant_segment_state vss
JOIN element_variants ev ON vss.variant_id = ev.id
WHERE vss.experiment_id = 'YOUR_EXPERIMENT_ID'
ORDER BY vss.segment_key, vss.conversion_rate DESC;
*/


-- ============================================================================
-- ROLLBACK PLAN (si algo sale mal)
-- ============================================================================
-- DROP MATERIALIZED VIEW IF EXISTS segment_performance_summary;
-- DROP FUNCTION IF EXISTS increment_variant_segment_conversion(UUID, VARCHAR);
-- DROP FUNCTION IF EXISTS increment_variant_segment_allocation(UUID, VARCHAR);
-- DROP FUNCTION IF EXISTS ensure_variant_segment_state(UUID, VARCHAR, UUID);
-- DROP TABLE IF EXISTS variant_segment_state;
-- ALTER TABLE assignments DROP COLUMN IF EXISTS segment_key;
