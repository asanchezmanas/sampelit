document.addEventListener('alpine:init', () => {
    Alpine.data('experimentDetail', () => ({
        loading: true,
        experimentId: null, // Will extract from URL or context
        data: {
            experiment_name: 'Loading...',
            status: 'active',
            total_visitors: 0,
            total_conversions: 0,
            overall_conversion_rate: 0,
            statistical_significance: 0,
            elements: []
        },
        activeTab: 'overview',
        charts: {
            conversion: null,
            bayesian: null
        },

        init() {
            // Extract ID from URL query param for now, or mock
            // In a real app, this might come from the path /experiment/123
            // For now, we'll try to find it in URL params or default to a demo ID
            const urlParams = new URLSearchParams(window.location.search);
            this.experimentId = urlParams.get('id');

            this.darkMode = JSON.parse(localStorage.getItem('darkMode')) || false;
            this.$watch('darkMode', val => {
                localStorage.setItem('darkMode', JSON.stringify(val));
                this.updateChartsTheme();
            });

            this.fetchData();
        },

        async fetchData() {
            if (!this.experimentId) {
                console.warn("No experiment ID found, using mock data for UI demo");
                this.loadMockData();
                return;
            }

            this.loading = true;
            try {
                const client = new APIClient();
                const response = await client.get(`/analytics/experiment/${this.experimentId}`);

                if (response) {
                    this.data = response;
                    this.processDataForCharts();
                }
            } catch (error) {
                console.error("Failed to fetch experiment details:", error);
                this.loadMockData(); // Fallback
            } finally {
                this.loading = false;
            }
        },

        processDataForCharts() {
            // 1. Bayesian Gauge & Stats
            // We take the first element's stats for the main gauge and top-level significance
            let probability = 0;
            if (this.data.elements && this.data.elements.length > 0) {
                const primaryElement = this.data.elements[0];

                // Bayesian Prob
                if (primaryElement.bayesian_stats && primaryElement.bayesian_stats.winner) {
                    probability = primaryElement.bayesian_stats.winner.probability_best * 100;
                }

                // Business Impact Calculation
                // Calculate "Extra Conversions" generated by the uplift vs baseline
                // Assuming Index 0 is control/baseline for now, or find lowest conversion rate
                if (this.data.elements && this.data.elements.length > 0) {
                    const variants = this.data.elements[0].variants || [];
                    if (variants.length >= 2) {
                        // Simple heuristic: Compare Winner conversion rate vs Control (Variant A/0)
                        // If winner is index 0, compare vs next best.
                        const control = variants[0];
                        const winner = variants.find(v => v.variant_index === this.data.elements[0].best_variant_index) || variants[0];

                        if (winner && control && winner.conversion_rate > control.conversion_rate) {
                            const upliftRate = winner.conversion_rate - control.conversion_rate;
                            // Estimate total additional conversions over the total traffic if this variant had been 100%
                            // Or just absolute extra conversions gained SO FAR in the experiment
                            const totalAllocations = variants.reduce((acc, v) => acc + v.allocations, 0);
                            const extraConversions = Math.round(totalAllocations * upliftRate);
                            this.data.business_impact = {
                                extra_conversions: extraConversions,
                                uplift_percentage: ((winner.conversion_rate - control.conversion_rate) / control.conversion_rate * 100).toFixed(1)
                            };
                        }
                    }
                }

                // Statistical Significance (from element flags or bayesian)
                // If the backend says it's significant, we show high confidence, otherwise we show the probability
                if (primaryElement.statistical_significance) {
                    this.data.statistical_significance = probability.toFixed(1);
                } else {
                    this.data.statistical_significance = probability.toFixed(1);
                }

                // Enrich variants for Table Display
                // 1. Find control (first variant or is_control flag)
                const variants = primaryElement.variants || [];
                const control = variants.find(v => v.is_control) || variants[0];
                const bayesianResults = (primaryElement.bayesian_stats && primaryElement.bayesian_stats.variants) ? primaryElement.bayesian_stats.variants : [];

                primaryElement.variants = variants.map(v => {
                    // Match with bayesian result
                    const bayesianVar = bayesianResults.find(b => b.variant_id === v.variant_id) || {};

                    // Calculate Uplift vs Control
                    let uplift = 0;
                    if (control && control.conversion_rate > 0) {
                        uplift = ((v.conversion_rate - control.conversion_rate) / control.conversion_rate) * 100;
                    }

                    return {
                        ...v,
                        uplift: uplift,
                        probability_best: (bayesianVar.probability_best || 0) * 100,
                        is_control: v === control
                    };
                });
            } else {
                this.data.statistical_significance = 0;
            }
            this.renderBayesianChart(probability);

            // 2. Conversion Chart
            // Parse daily stats if available
            let chartData = null;
            if (primaryElement.daily_stats && primaryElement.daily_stats.length > 0) {
                // Pivot data: dates as categories, variants as series
                const dates = primaryElement.daily_stats.map(d => {
                    // Format date to MM-DD
                    const date = new Date(d.date);
                    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                });

                // Get unique variant IDs
                const variants = primaryElement.variants || [];
                const series = variants.map(v => {
                    return {
                        name: v.name || 'Variant',
                        data: []
                    };
                });

                // Fill series data
                primaryElement.daily_stats.forEach(day => {
                    day.variant_stats.forEach(vs => {
                        const seriesItem = series.find(s => s.name === vs.name); // Match by name or ID
                        if (seriesItem) {
                            seriesItem.data.push((vs.conversion_rate * 100).toFixed(1));
                        }
                    });
                });

                chartData = { categories: dates, series: series };
            }

            this.renderConversionChart(chartData);
        },

        loadMockData() {
            this.data = {
                experiment_name: 'Homepage Hero Test',
                status: 'active',
                total_visitors: 12450,
                total_conversions: 1543,
                overall_conversion_rate: 0.124,
                elements: [{
                    bayesian_stats: {
                        winner: { probability_best: 0.952 }
                    },
                    variants: [
                        { name: 'Control', conversion_rate: 0.10 },
                        { name: 'Variant B', conversion_rate: 0.12 }
                    ],
                    daily_stats: [
                        { date: '2025-01-01', variant_stats: [{ name: 'Control', conversion_rate: 0.08 }, { name: 'Variant B', conversion_rate: 0.09 }] },
                        { date: '2025-01-02', variant_stats: [{ name: 'Control', conversion_rate: 0.09 }, { name: 'Variant B', conversion_rate: 0.10 }] },
                        { date: '2025-01-03', variant_stats: [{ name: 'Control', conversion_rate: 0.095 }, { name: 'Variant B', conversion_rate: 0.11 }] },
                        { date: '2025-01-04', variant_stats: [{ name: 'Control', conversion_rate: 0.10 }, { name: 'Variant B', conversion_rate: 0.12 }] }
                    ]
                }]
            };
            this.processDataForCharts();
            this.loading = false;
        },

        renderBayesianChart(probability) {
            const options = {
                series: [probability.toFixed(1)],
                chart: {
                    type: 'radialBar',
                    height: 320,
                    fontFamily: 'Manrope, sans-serif',
                },
                plotOptions: {
                    radialBar: {
                        startAngle: -135,
                        endAngle: 135,
                        hollow: {
                            margin: 15,
                            size: '65%',
                            background: 'transparent',
                        },
                        track: {
                            background: this.darkMode ? '#374151' : '#f1f5f9',
                            strokeWidth: '100%',
                            margin: 0,
                        },
                        dataLabels: { show: false }
                    }
                },
                fill: {
                    type: 'gradient',
                    gradient: {
                        shade: 'dark',
                        type: 'horizontal',
                        shadeIntensity: 0.5,
                        gradientToColors: ['#10b981'],
                        inverseColors: true,
                        opacityFrom: 1,
                        opacityTo: 1,
                        stops: [0, 100]
                    }
                },
                stroke: { lineCap: 'round' },
                colors: ['#1E3A8A'],
                labels: ['Confidence'],
            };

            const chartEl = document.querySelector("#bayesianChart");
            if (chartEl) {
                if (this.charts.bayesian) this.charts.bayesian.destroy();
                this.charts.bayesian = new ApexCharts(chartEl, options);
                this.charts.bayesian.render();
            }

            // Update text manually if needed or bind via Alpine
            // (We are binding via Alpine in HTML: x-text="...")
        },

        renderConversionChart(chartData = null) {
            // Default mock data if no real data
            let days = ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Day 6', 'Day 7'];
            let series = [
                { name: 'Control', data: [10, 10.2, 10.5, 10.3, 10.8, 11.0, 11.1] },
                { name: 'Variant B', data: [10, 11.5, 12.0, 12.5, 13.0, 13.5, 13.8] }
            ];

            // Use real data if passed
            if (chartData) {
                days = chartData.categories;
                series = chartData.series;
            }

            const options = {
                series: series,
                chart: {
                    type: 'area',
                    height: 320,
                    fontFamily: 'Manrope, sans-serif',
                    toolbar: { show: false },
                    animations: { enabled: true }
                },
                colors: ['#94a3b8', '#10b981', '#3b82f6', '#f59e0b'], // Extended color palette for more variants
                fill: {
                    type: 'gradient',
                    gradient: {
                        shadeIntensity: 1,
                        opacityFrom: 0.4,
                        opacityTo: 0.05,
                        stops: [0, 90, 100]
                    }
                },
                dataLabels: { enabled: false },
                stroke: { curve: 'smooth', width: 2 },
                xaxis: {
                    categories: days,
                    axisBorder: { show: false },
                    axisTicks: { show: false },
                    labels: { style: { colors: '#9CA3AF', fontSize: '11px' } }
                },
                yaxis: {
                    labels: { style: { colors: '#9CA3AF', fontSize: '11px' }, formatter: (val) => val + '%' }
                },
                grid: {
                    borderColor: this.darkMode ? '#374151' : '#f1f5f9',
                    strokeDashArray: 4
                },
                tooltip: { theme: this.darkMode ? 'dark' : 'light' }
            };

            const chartEl = document.querySelector("#conversionChart");
            if (chartEl) {
                if (this.charts.conversion) this.charts.conversion.destroy();
                this.charts.conversion = new ApexCharts(chartEl, options);
                this.charts.conversion.render();
            }
        },

        updateChartsTheme() {
            // Re-render to pick up new logic or updateOptions
            if (this.charts.bayesian) {
                this.charts.bayesian.updateOptions({
                    plotOptions: { radialBar: { track: { background: this.darkMode ? '#374151' : '#f1f5f9' } } }
                });
            }
            if (this.charts.conversion) {
                this.charts.conversion.updateOptions({
                    grid: { borderColor: this.darkMode ? '#374151' : '#f1f5f9' },
                    tooltip: { theme: this.darkMode ? 'dark' : 'light' }
                });
            }
        }
    }));
});
